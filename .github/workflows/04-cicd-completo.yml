name: "04 - Build, Test, Deploy Completo"

# Pipeline completo de CI/CD con todas las capacidades avanzadas
# Demuestra: cache, matrix avanzada, containers, services, environments

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      skip-tests:
        description: 'Saltar tests'
        type: boolean
        default: false
      deploy-env:
        description: 'Entorno de deploy'
        type: choice
        options:
          - none
          - dev
          - staging
          - production
        default: none

env:
  # Variables globales para todo el workflow
  PROJECT_NAME: "MiAplicacion"
  DOCKER_REGISTRY: "ghcr.io"
  PYTHON_VERSION: "3.11"
  NODE_VERSION: "20"

jobs:
  # ============================================================================
  # JOB 1: INFORMACIÃ“N DEL CONTEXTO
  # ============================================================================
  context:
    name: "InformaciÃ³n del Contexto"
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      target-env: ${{ steps.check.outputs.target-env }}
    
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Historial completo para versionado
      
      - name: "Generar versiÃ³n"
        id: version
        run: |
          # Generar versiÃ³n basada en git tags y commits
          if git describe --tags --exact-match 2>/dev/null; then
            VERSION=$(git describe --tags --exact-match)
          else
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0")
            COMMITS=$(git rev-list --count HEAD ^$(git rev-list -1 $LAST_TAG) 2>/dev/null || echo "0")
            SHORT_SHA=$(git rev-parse --short HEAD)
            VERSION="${LAST_TAG}-${COMMITS}-${SHORT_SHA}"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ VersiÃ³n: $VERSION"
      
      - name: "Determinar si hacer deploy"
        id: check
        run: |
          SHOULD_DEPLOY="false"
          TARGET_ENV="none"
          
          # Deploy manual
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ inputs.deploy-env }}" != "none" ]; then
            SHOULD_DEPLOY="true"
            TARGET_ENV="${{ inputs.deploy-env }}"
          
          # Deploy automÃ¡tico en push a main
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/main" ]; then
            SHOULD_DEPLOY="true"
            TARGET_ENV="staging"
          
          # Deploy automÃ¡tico en push a develop
          elif [ "${{ github.event_name }}" == "push" ] && [ "${{ github.ref }}" == "refs/heads/develop" ]; then
            SHOULD_DEPLOY="true"
            TARGET_ENV="dev"
          fi
          
          echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "target-env=$TARGET_ENV" >> $GITHUB_OUTPUT
          
          echo "ðŸš€ Deploy: $SHOULD_DEPLOY"
          echo "ðŸŒ Entorno: $TARGET_ENV"
      
      - name: "Resumen del contexto"
        run: |
          cat >> $GITHUB_STEP_SUMMARY << EOF
          # ðŸ“‹ Contexto del Workflow
          
          ## Evento
          - **Tipo:** \`${{ github.event_name }}\`
          - **Ref:** \`${{ github.ref }}\`
          - **Actor:** @${{ github.actor }}
          
          ## CÃ³digo
          - **Repositorio:** ${{ github.repository }}
          - **Branch:** ${{ github.ref_name }}
          - **Commit:** \`${{ github.sha }}\`
          - **VersiÃ³n:** \`${{ steps.version.outputs.version }}\`
          
          ## Decisiones
          - **Deploy:** ${{ steps.check.outputs.should-deploy }}
          - **Entorno:** ${{ steps.check.outputs.target-env }}
          - **Saltar tests:** ${{ inputs.skip-tests || false }}
          EOF

  # ============================================================================
  # JOB 2: LINTING Y ANÃLISIS ESTÃTICO
  # ============================================================================
  lint:
    name: "Lint (${{ matrix.tool }})"
    runs-on: ubuntu-latest
    strategy:
      matrix:
        tool: [python, javascript, docker]
      fail-fast: false
    
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
      
      # Python linting
      - name: "Setup Python"
        if: matrix.tool == 'python'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: "Lint Python"
        if: matrix.tool == 'python'
        run: |
          pip install ruff black isort
          echo "ðŸ” Verificando formato con black..."
          black --check . || echo "âš ï¸ Requiere formateo"
          
          echo "ðŸ” Verificando imports con isort..."
          isort --check-only . || echo "âš ï¸ Requiere ordenar imports"
          
          echo "ðŸ” Linting con ruff..."
          ruff check . || echo "âš ï¸ Issues encontrados"
          
          echo "âœ… Python lint completado"
      
      # JavaScript linting
      - name: "Setup Node.js"
        if: matrix.tool == 'javascript'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: "Lint JavaScript"
        if: matrix.tool == 'javascript'
        run: |
          if [ -f "package.json" ]; then
            npm ci
            npm run lint || echo "âš ï¸ Lint issues"
          else
            echo "â„¹ï¸ No package.json encontrado"
          fi
      
      # Docker linting
      - name: "Lint Dockerfile"
        if: matrix.tool == 'docker'
        run: |
          # Instalar hadolint
          wget -qO /usr/local/bin/hadolint https://github.com/hadolint/hadolint/releases/latest/download/hadolint-Linux-x86_64
          chmod +x /usr/local/bin/hadolint
          
          if [ -f "Dockerfile" ]; then
            echo "ðŸ” Analizando Dockerfile..."
            hadolint Dockerfile || echo "âš ï¸ Issues encontrados"
          else
            echo "â„¹ï¸ No Dockerfile encontrado"
          fi

  # ============================================================================
  # JOB 3: TESTS CON MATRIZ COMPLEJA
  # ============================================================================
  test:
    name: "Test: ${{ matrix.os }} - ${{ matrix.language }} ${{ matrix.version }}"
    runs-on: ${{ matrix.os }}
    if: inputs.skip-tests != true
    
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        language: [python]
        version: ['3.10', '3.11', '3.12']
        # Excluir combinaciones especÃ­ficas
        exclude:
          - os: macos-latest
            version: '3.10'
          - os: windows-latest
            version: '3.12'
    
    # Services: Contenedores para tests (solo Linux)
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
        # Solo en Linux
        if: ${{ matrix.os == 'ubuntu-latest' }}
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
        if: ${{ matrix.os == 'ubuntu-latest' }}
    
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
      
      - name: "Setup ${{ matrix.language }} ${{ matrix.version }}"
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.version }}
          cache: 'pip'
      
      - name: "Instalar dependencias"
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov pytest-xdist pytest-timeout
          
          # Instalar dependencias del proyecto
          if [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          fi
        shell: bash
      
      - name: "Ejecutar tests unitarios"
        env:
          DATABASE_URL: postgresql://postgres:testpass@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379
        run: |
          # Tests en paralelo con coverage
          pytest tests/ \
            -v \
            --cov=. \
            --cov-report=xml \
            --cov-report=html \
            --junit-xml=junit.xml \
            -n auto \
            --timeout=300 \
            || true
          
          echo "âœ… Tests completados"
        shell: bash
      
      - name: "Subir resultados de tests"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.os }}-${{ matrix.version }}
          path: |
            junit.xml
            htmlcov/
            coverage.xml
          retention-days: 5
      
      - name: "Publicar reporte de coverage"
        if: matrix.os == 'ubuntu-latest' && matrix.version == '3.11'
        run: |
          if [ -f "coverage.xml" ]; then
            # AquÃ­ se podrÃ­a enviar a Codecov, Coveralls, etc.
            echo "ðŸ“Š Coverage generado"
          fi

  # ============================================================================
  # JOB 4: TESTS DE INTEGRACIÃ“N (con container)
  # ============================================================================
  integration-test:
    name: "Tests de IntegraciÃ³n"
    runs-on: ubuntu-latest
    if: inputs.skip-tests != true
    
    # Ejecutar en container
    container:
      image: python:3.11-slim
      env:
        DATABASE_URL: postgresql://postgres:testpass@postgres:5432/testdb
        REDIS_URL: redis://redis:6379
      options: --user root
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: testpass
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
    
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
      
      - name: "Instalar dependencias del sistema"
        run: |
          apt-get update
          apt-get install -y --no-install-recommends \
            postgresql-client \
            redis-tools \
            curl
      
      - name: "Verificar servicios"
        run: |
          echo "ðŸ” Verificando PostgreSQL..."
          pg_isready -h postgres -U postgres
          
          echo "ðŸ” Verificando Redis..."
          redis-cli -h redis ping
          
          echo "âœ… Servicios disponibles"
      
      - name: "Instalar dependencias Python"
        run: |
          pip install --upgrade pip
          pip install pytest psycopg2-binary redis
      
      - name: "Ejecutar tests de integraciÃ³n"
        run: |
          # Simular tests de integraciÃ³n
          cat > test_integration.py << 'EOF'
          import os
          def test_database():
              db_url = os.getenv('DATABASE_URL')
              assert db_url is not None
              assert 'postgres' in db_url
              print("âœ… Database URL configurado")
          
          def test_redis():
              redis_url = os.getenv('REDIS_URL')
              assert redis_url is not None
              assert 'redis' in redis_url
              print("âœ… Redis URL configurado")
          EOF
          
          pytest test_integration.py -v
          echo "âœ… Tests de integraciÃ³n completados"

  # ============================================================================
  # JOB 5: BUILD DE ARTEFACTOS
  # ============================================================================
  build:
    name: "Build Artifacts"
    runs-on: ubuntu-latest
    needs: [context, lint]
    outputs:
      image-tag: ${{ steps.build.outputs.image-tag }}
    
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
      
      - name: "Setup Python"
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
      
      - name: "Build de aplicaciÃ³n"
        id: build
        env:
          VERSION: ${{ needs.context.outputs.version }}
        run: |
          echo "ðŸ—ï¸ Building versiÃ³n $VERSION"
          
          # Crear distribuciÃ³n
          mkdir -p dist
          
          # Simular build
          cat > dist/app.py << EOF
          #!/usr/bin/env python3
          print("$PROJECT_NAME v$VERSION")
          EOF
          chmod +x dist/app.py
          
          # Crear metadata
          cat > dist/metadata.json << EOF
          {
            "name": "$PROJECT_NAME",
            "version": "$VERSION",
            "buildDate": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}"
          }
          EOF
          
          IMAGE_TAG="${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:$VERSION"
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          echo "âœ… Build completado"
      
      - name: "Subir artifacts"
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ needs.context.outputs.version }}
          path: dist/
          retention-days: 30

  # ============================================================================
  # JOB 6: BUILD Y PUSH DE DOCKER IMAGE
  # ============================================================================
  docker-build:
    name: "Build Docker Image"
    runs-on: ubuntu-latest
    needs: [context, build, test]
    if: |
      always() &&
      needs.context.outputs.should-deploy == 'true' &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')
    
    steps:
      - name: "Checkout"
        uses: actions/checkout@v4
      
      - name: "Crear Dockerfile"
        run: |
          cat > Dockerfile << 'EOF'
          FROM python:3.11-slim
          WORKDIR /app
          COPY dist/ /app/
          CMD ["python", "app.py"]
          EOF
      
      - name: "Descargar artifacts"
        uses: actions/download-artifact@v4
        with:
          name: build-${{ needs.context.outputs.version }}
          path: dist/
      
      - name: "Build Docker image"
        run: |
          IMAGE_TAG="${{ needs.build.outputs.image-tag }}"
          docker build -t $IMAGE_TAG .
          docker tag $IMAGE_TAG ${{ env.DOCKER_REGISTRY }}/${{ github.repository }}:latest
          
          echo "ðŸ³ Image: $IMAGE_TAG"
      
      - name: "Guardar imagen"
        run: |
          mkdir -p /tmp/docker
          docker save ${{ needs.build.outputs.image-tag }} | gzip > /tmp/docker/image.tar.gz
      
      - name: "Subir imagen como artifact"
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ needs.context.outputs.version }}
          path: /tmp/docker/image.tar.gz
          retention-days: 7

  # ============================================================================
  # JOB 7: DEPLOY
  # ============================================================================
  deploy:
    name: "Deploy a ${{ needs.context.outputs.target-env }}"
    runs-on: ubuntu-latest
    needs: [context, docker-build]
    if: needs.context.outputs.should-deploy == 'true'
    environment:
      name: ${{ needs.context.outputs.target-env }}
      url: https://${{ needs.context.outputs.target-env }}.example.com
    
    steps:
      - name: "Descargar Docker image"
        uses: actions/download-artifact@v4
        with:
          name: docker-image-${{ needs.context.outputs.version }}
      
      - name: "Deploy"
        env:
          ENV: ${{ needs.context.outputs.target-env }}
          VERSION: ${{ needs.context.outputs.version }}
        run: |
          echo "ðŸš€ Desplegando $VERSION a $ENV"
          
          # Cargar imagen
          docker load < image.tar.gz
          
          # Simular deployment
          echo "  ðŸ“¦ Extrayendo imagen..."
          sleep 2
          echo "  âš¡ Iniciando contenedor..."
          sleep 2
          echo "  âœ… Deployment completado"
          
          echo "ðŸ”— URL: https://$ENV.example.com"

  # ============================================================================
  # JOB 8: REPORTE FINAL
  # ============================================================================
  report:
    name: "Reporte Final"
    runs-on: ubuntu-latest
    needs: [context, lint, test, integration-test, build, docker-build, deploy]
    if: always()
    
    steps:
      - name: "Generar reporte"
        run: |
          cat >> $GITHUB_STEP_SUMMARY << 'EOF'
          # ðŸŽ¯ Reporte del Pipeline CI/CD
          
          ## ðŸ“¦ Build
          - **VersiÃ³n:** `${{ needs.context.outputs.version }}`
          - **Commit:** `${{ github.sha }}`
          
          ## âœ… Resultados
          - **Lint:** ${{ needs.lint.result }}
          - **Tests Unitarios:** ${{ needs.test.result }}
          - **Tests IntegraciÃ³n:** ${{ needs.integration-test.result }}
          - **Build:** ${{ needs.build.result }}
          - **Docker Build:** ${{ needs.docker-build.result }}
          - **Deploy:** ${{ needs.deploy.result }}
          
          ## ðŸš€ Deployment
          - **Deploy realizado:** ${{ needs.context.outputs.should-deploy }}
          - **Entorno:** ${{ needs.context.outputs.target-env }}
          
          ---
          *Pipeline ejecutado por @${{ github.actor }}*
          EOF

